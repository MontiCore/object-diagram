/*
 * ========================================================== AST for JavaDSL
 */
objectdiagram HelloWorld_AST {
  @!CompilationUnit(1,0):ASTCompilationUnit {
    symbol = Optional.Empty;
    enclosingScope = @HelloWorld!ArtifactScope;
    spannedScope = Optional.Empty;
    packageDeclaration = @!PackageDeclaration(1,0):ASTPackageDeclaration {
      symbol = Optional.Empty;
      enclosingScope = @HelloWorld!ArtifactScope;
      spannedScope = Optional.Empty;
      annotations = []; // *size: 0
      qualifiedName = @simpleTestClasses!QualifiedName(1,8):ASTQualifiedName {
        parts = ["simpleTestClasses"];
      };
    };
    importDeclarations = []; // *size: 0
    typeDeclarations = // *size: 1
      @HelloWorld!ClassDeclaration(3,0):ASTClassDeclaration {
        symbol = @HelloWorld!Symbol(3,0);
        enclosingScope = @HelloWorld!ArtifactScope;
        spanningScope = @HelloWorld!Scope;
        modifiers = // *size: 1
          @!PrimitiveModifier(3,0):ASTPrimitiveModifier {
            symbol = Optional.Empty;
            enclosingScope = @HelloWorld!Scope;
            spannedScope = Optional.Empty;
            modifier = 2;
          };
        name = "HelloWorld";
        typeParameters = Optional.Empty;
        superClass = Optional.Empty;
        implementedInterfaces = []; // *size: 0
        classBody = @!ClassBody(3,24):ASTClassBody {
          symbol = Optional.Empty;
          enclosingScope = @HelloWorld!Scope;
          spannedScope = Optional.Empty;
          classBodyDeclarations = // *size: 1
            @!MethodDeclaration(4,2):ASTMethodDeclaration {
              symbol = @main!Symbol(4,2);
              enclosingScope = @HelloWorld!Scope;
              spanningScope = @main!Scope;
              methodSignature = @main!MethodSignature(4,2):ASTMethodSignature {
                symbol = Optional.Empty;
                enclosingScope = @main!Scope;
                spannedScope = Optional.Empty;
                modifiers = // *size: 2
                  @!PrimitiveModifier(4,2):ASTPrimitiveModifier {
                    symbol = Optional.Empty;
                    enclosingScope = @main!Scope;
                    spannedScope = Optional.Empty;
                    modifier = 2;
                  },
                  @!PrimitiveModifier(4,9):ASTPrimitiveModifier {
                    symbol = Optional.Empty;
                    enclosingScope = @main!Scope;
                    spannedScope = Optional.Empty;
                    modifier = 4;
                  };
                typeParameters = Optional.Empty;
                returnType = @!VoidType(4,16):ASTVoidType {
                };
                name = "main";
                formalParameters = @!FormalParameters(4,25):ASTFormalParameters {
                  symbol = Optional.Empty;
                  enclosingScope = @main!Scope;
                  spannedScope = Optional.Empty;
                  formalParameterListing = @!FormalParameterListing(4,26):ASTFormalParameterListing {
                    symbol = Optional.Empty;
                    enclosingScope = @main!Scope;
                    spannedScope = Optional.Empty;
                    formalParameters = // *size: 1
                      @args!FormalParameter(4,26):ASTFormalParameter {
                        symbol = @args!Symbol(4,26);
                        enclosingScope = @main!Scope;
                        spannedScope = Optional.Empty;
                        primitiveModifiers = []; // *size: 0
                        type = @!ComplexArrayType(4,26):ASTComplexArrayType {
                          componentType = @!ComplexReferenceType(4,26):ASTComplexReferenceType {
                            simpleReferenceTypes = 
                              @String!SimpleReferenceType(4,26):ASTSimpleReferenceType {
                                names = ["String"];
                              };
                          };
                          dimensions = 1;
                        };
                        declaratorId = @args!DeclaratorId(4,35):ASTDeclaratorId {
                          symbol = Optional.Empty;
                          enclosingScope = @main!Scope;
                          spannedScope = Optional.Empty;
                          name = "args";
                          dim = [];
                        };
                      };
                    lastFormalParameter = Optional.Empty;
                  };
                };
                r__throws = Optional.Empty;
                dim = [];
              };
              methodBody = @!JavaBlock(4,41):ASTJavaBlock {
                symbol = Optional.Empty;
                enclosingScope = @main!Scope;
                spannedScope = Optional.Empty;
                blockStatements = // *size: 1
                  @!ExpressionStatement(5,4):ASTExpressionStatement {
                    symbol = Optional.Empty;
                    enclosingScope = @main!Scope;
                    spannedScope = Optional.Empty;
                    expression = @!Expression(5,4):ASTExpression {
                      symbol = Optional.Empty;
                      enclosingScope = @main!Scope;
                      spannedScope = Optional.Empty;
                      primaryExpression = Optional.Empty;
                      name = Optional.Empty;
                      innerCreator = Optional.Empty;
                      superSuffix = Optional.Empty;
                      explicitGenericInvocation = Optional.Empty;
                      arrayExpression = Optional.Empty;
                      indexExpression = Optional.Empty;
                      callExpression = @println!Expression(5,4):ASTExpression {
                        symbol = Optional.Empty;
                        enclosingScope = @main!Scope;
                        spannedScope = Optional.Empty;
                        primaryExpression = Optional.Empty;
                        name = "println";
                        innerCreator = Optional.Empty;
                        superSuffix = Optional.Empty;
                        explicitGenericInvocation = Optional.Empty;
                        arrayExpression = Optional.Empty;
                        indexExpression = Optional.Empty;
                        callExpression = Optional.Empty;
                        parameterExpression = []; // *size: 0
                        creator = Optional.Empty;
                        typeCastType = Optional.Empty;
                        expression = @out!Expression(5,4):ASTExpression {
                          symbol = Optional.Empty;
                          enclosingScope = @main!Scope;
                          spannedScope = Optional.Empty;
                          primaryExpression = Optional.Empty;
                          name = "out";
                          innerCreator = Optional.Empty;
                          superSuffix = Optional.Empty;
                          explicitGenericInvocation = Optional.Empty;
                          arrayExpression = Optional.Empty;
                          indexExpression = Optional.Empty;
                          callExpression = Optional.Empty;
                          parameterExpression = []; // *size: 0
                          creator = Optional.Empty;
                          typeCastType = Optional.Empty;
                          expression = @!Expression(5,4!2):ASTExpression {
                            symbol = Optional.Empty;
                            enclosingScope = @main!Scope;
                            spannedScope = Optional.Empty;
                            primaryExpression = @System!PrimaryExpression(5,4):ASTPrimaryExpression {
                              symbol = Optional.Empty;
                              enclosingScope = @main!Scope;
                              spannedScope = Optional.Empty;
                              expression = Optional.Empty;
                              literal = Optional.Empty;
                              name = "System";
                              returnType = Optional.Empty;
                              explicitGenericInvocation = Optional.Empty;
                              typeArguments = Optional.Empty;
                              arguments = Optional.Empty;
                              r__super = false;
                              r__this = false;
                            };
                            name = Optional.Empty;
                            innerCreator = Optional.Empty;
                            superSuffix = Optional.Empty;
                            explicitGenericInvocation = Optional.Empty;
                            arrayExpression = Optional.Empty;
                            indexExpression = Optional.Empty;
                            callExpression = Optional.Empty;
                            parameterExpression = []; // *size: 0
                            creator = Optional.Empty;
                            typeCastType = Optional.Empty;
                            expression = Optional.Empty;
                            instanceofType = Optional.Empty;
                            condition = Optional.Empty;
                            trueExpression = Optional.Empty;
                            falseExpression = Optional.Empty;
                            leftExpression = Optional.Empty;
                            rightExpression = Optional.Empty;
                            suffixOp = Optional.Empty;
                            prefixOp = Optional.Empty;
                            booleanNot = Optional.Empty;
                            multiplicativeOp = Optional.Empty;
                            additiveOp = Optional.Empty;
                            shiftOp = Optional.Empty;
                            comparison = Optional.Empty;
                            identityTest = Optional.Empty;
                            binaryAndOp = Optional.Empty;
                            binaryXorOp = Optional.Empty;
                            binaryOrOp = Optional.Empty;
                            booleanAndOp = Optional.Empty;
                            booleanOrOp = Optional.Empty;
                            assignment = Optional.Empty;
                            r__this = false;
                          };
                          instanceofType = Optional.Empty;
                          condition = Optional.Empty;
                          trueExpression = Optional.Empty;
                          falseExpression = Optional.Empty;
                          leftExpression = Optional.Empty;
                          rightExpression = Optional.Empty;
                          suffixOp = Optional.Empty;
                          prefixOp = Optional.Empty;
                          booleanNot = Optional.Empty;
                          multiplicativeOp = Optional.Empty;
                          additiveOp = Optional.Empty;
                          shiftOp = Optional.Empty;
                          comparison = Optional.Empty;
                          identityTest = Optional.Empty;
                          binaryAndOp = Optional.Empty;
                          binaryXorOp = Optional.Empty;
                          binaryOrOp = Optional.Empty;
                          booleanAndOp = Optional.Empty;
                          booleanOrOp = Optional.Empty;
                          assignment = Optional.Empty;
                          r__this = false;
                        };
                        instanceofType = Optional.Empty;
                        condition = Optional.Empty;
                        trueExpression = Optional.Empty;
                        falseExpression = Optional.Empty;
                        leftExpression = Optional.Empty;
                        rightExpression = Optional.Empty;
                        suffixOp = Optional.Empty;
                        prefixOp = Optional.Empty;
                        booleanNot = Optional.Empty;
                        multiplicativeOp = Optional.Empty;
                        additiveOp = Optional.Empty;
                        shiftOp = Optional.Empty;
                        comparison = Optional.Empty;
                        identityTest = Optional.Empty;
                        binaryAndOp = Optional.Empty;
                        binaryXorOp = Optional.Empty;
                        binaryOrOp = Optional.Empty;
                        booleanAndOp = Optional.Empty;
                        booleanOrOp = Optional.Empty;
                        assignment = Optional.Empty;
                        r__this = false;
                      };
                      parameterExpression = // *size: 1
                        @!Expression(5,23):ASTExpression {
                          symbol = Optional.Empty;
                          enclosingScope = @main!Scope;
                          spannedScope = Optional.Empty;
                          primaryExpression = @!PrimaryExpression(5,23):ASTPrimaryExpression {
                            symbol = Optional.Empty;
                            enclosingScope = @main!Scope;
                            spannedScope = Optional.Empty;
                            expression = Optional.Empty;
                            literal = @Hello_World_!StringLiteral(5,23):ASTStringLiteral {
                              source = "Hello World!";
                            };
                            name = Optional.Empty;
                            returnType = Optional.Empty;
                            explicitGenericInvocation = Optional.Empty;
                            typeArguments = Optional.Empty;
                            arguments = Optional.Empty;
                            r__super = false;
                            r__this = false;
                          };
                          name = Optional.Empty;
                          innerCreator = Optional.Empty;
                          superSuffix = Optional.Empty;
                          explicitGenericInvocation = Optional.Empty;
                          arrayExpression = Optional.Empty;
                          indexExpression = Optional.Empty;
                          callExpression = Optional.Empty;
                          parameterExpression = []; // *size: 0
                          creator = Optional.Empty;
                          typeCastType = Optional.Empty;
                          expression = Optional.Empty;
                          instanceofType = Optional.Empty;
                          condition = Optional.Empty;
                          trueExpression = Optional.Empty;
                          falseExpression = Optional.Empty;
                          leftExpression = Optional.Empty;
                          rightExpression = Optional.Empty;
                          suffixOp = Optional.Empty;
                          prefixOp = Optional.Empty;
                          booleanNot = Optional.Empty;
                          multiplicativeOp = Optional.Empty;
                          additiveOp = Optional.Empty;
                          shiftOp = Optional.Empty;
                          comparison = Optional.Empty;
                          identityTest = Optional.Empty;
                          binaryAndOp = Optional.Empty;
                          binaryXorOp = Optional.Empty;
                          binaryOrOp = Optional.Empty;
                          booleanAndOp = Optional.Empty;
                          booleanOrOp = Optional.Empty;
                          assignment = Optional.Empty;
                          r__this = false;
                        };
                      creator = Optional.Empty;
                      typeCastType = Optional.Empty;
                      expression = Optional.Empty;
                      instanceofType = Optional.Empty;
                      condition = Optional.Empty;
                      trueExpression = Optional.Empty;
                      falseExpression = Optional.Empty;
                      leftExpression = Optional.Empty;
                      rightExpression = Optional.Empty;
                      suffixOp = Optional.Empty;
                      prefixOp = Optional.Empty;
                      booleanNot = Optional.Empty;
                      multiplicativeOp = Optional.Empty;
                      additiveOp = Optional.Empty;
                      shiftOp = Optional.Empty;
                      comparison = Optional.Empty;
                      identityTest = Optional.Empty;
                      binaryAndOp = Optional.Empty;
                      binaryXorOp = Optional.Empty;
                      binaryOrOp = Optional.Empty;
                      booleanAndOp = Optional.Empty;
                      booleanOrOp = Optional.Empty;
                      assignment = Optional.Empty;
                      r__this = false;
                    };
                  };
              };
            };
        };
      };
}}

/*
 * ========================================================== Explanation
 * Shows the AST with all attributes as object diagram
 */
